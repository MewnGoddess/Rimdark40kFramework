using System.Collections.Generic;
using System.Linq;
using System.Text;
using RimWorld;
using Verse;

namespace Core40k;

public class RankCategoryDef : Def
{
    public List<RankCategorySpecificData> ranks = new List<RankCategorySpecificData>();
    
    public Dictionary<RankDef, RankCategorySpecificData> rankDict = new Dictionary<RankDef, RankCategorySpecificData>();
    
    public List<GeneDef> unlockedByGenes;
    public List<HediffDef> unlockedByHediffs;
    public List<TraitData> unlockedByTraits;
    public List<MemeDef> unlockedByMemes;
    
    public List<GeneDef> lockedByGenes;
    public List<HediffDef> lockedByHediffs;
    public List<TraitData> lockedByTraits;
    public List<MemeDef> lockedByMemes;
    
    public Gender genderLocked;
    public List<RankCategoryDef> incompatibleRankCategoryDef = new List<RankCategoryDef>();
    
    public override void ResolveReferences()
    {
        base.ResolveReferences();
        if (ranks.Count != ranks.Distinct().Count())
        {
            Log.Warning(defName + " has duplicate rank categories.");
        }
        rankDict = new Dictionary<RankDef, RankCategorySpecificData>();
        foreach (var rank in ranks)
        {
            rankDict.Add(rank.rankDef, rank);
        }
    }
    public virtual bool RankCategoryUnlockedFor(Pawn pawn)
    {
        //Genes
        if (!unlockedByGenes.NullOrEmpty())
        {
            if (pawn.genes == null || Enumerable.Any(unlockedByGenes, gene => !pawn.genes.HasActiveGene(gene)))
            {
                return false;
            }
        }
        if (!lockedByGenes.NullOrEmpty())
        {
            if (Enumerable.Any(lockedByGenes, gene => pawn.genes.HasActiveGene(gene)))
            {
                return false;
            }
        }

        //Traits
        if (!unlockedByTraits.NullOrEmpty())
        {
            if (pawn.story == null || Enumerable.Any(unlockedByTraits, traitData => !pawn.story.traits.HasTrait(traitData.traitDef, traitData.degree)))
            {
                return false;
            }
        }
        if (!lockedByTraits.NullOrEmpty())
        {
            if (Enumerable.Any(lockedByTraits, traitData => pawn.story.traits.HasTrait(traitData.traitDef, traitData.degree)) )
            {
                return false;
            }
        }

        //Hediffs
        if (!unlockedByHediffs.NullOrEmpty())
        {
            if (pawn.health == null || Enumerable.Any(unlockedByHediffs, hediffDef => !pawn.health.hediffSet.HasHediff(hediffDef)))
            {
                return false;
            }
        }
        if (!lockedByHediffs.NullOrEmpty())
        {
            if (Enumerable.Any(lockedByHediffs, hediffDef => pawn.health.hediffSet.HasHediff(hediffDef)))
            {
                return false;
            }
        }
        
        //Memes
        
        //Gender
        
        //Rank Category Incompatibilities

        return true;
    }
    
    public virtual string RankCategoryRequirementsNotMetFor(Pawn pawn)
    {
        var stringBuilder = new StringBuilder();
        var allRequirementUnlock = new List<string>();
        var allRequirementLock = new List<string>();
            
        if (pawn.genes != null && unlockedByGene != null && !pawn.genes.HasActiveGene(unlockedByGene))
        {
            allRequirementUnlock.Add("BEWH.Framework.RankSystem.CategoryRequiredGene".Translate(unlockedByGene.label.CapitalizeFirst()));
        }
            
        if (unlockedByHediff != null && !pawn.health.hediffSet.HasHediff(unlockedByHediff))
        {
            allRequirementUnlock.Add("BEWH.Framework.RankSystem.CategoryRequiredHediff".Translate(unlockedByHediff.label.CapitalizeFirst()));
        }
            
        if (unlockedByTrait != null && !pawn.story.traits.HasTrait(unlockedByTrait, unlockTraitDegree))
        {
            allRequirementUnlock.Add("BEWH.Framework.RankSystem.CategoryRequiredTrait".Translate(unlockedByTrait.DataAtDegree(unlockTraitDegree).label.CapitalizeFirst()));
        }

        if (allRequirementUnlock.Count > 0)
        {
            stringBuilder.Append("BEWH.Framework.RankSystem.CategoryRequiresUnlock".Translate(label.CapitalizeFirst()));
            for (var i = 0; i < allRequirementUnlock.Count; i++)
            {
                stringBuilder.Append(allRequirementUnlock[i]);
                if (i + 2 == allRequirementUnlock.Count)
                {
                    stringBuilder.Append("BEWH.Framework.RankSystem.And".Translate());
                }
                else if (i + 2 < allRequirementUnlock.Count)
                {
                    stringBuilder.Append(", ");
                }
            }
        }
        
        if (pawn.genes != null && lockedByGene != null && pawn.genes.HasActiveGene(lockedByGene))
        {
            allRequirementLock.Add("BEWH.Framework.RankSystem.CategoryRequiredGene".Translate(lockedByGene.label.CapitalizeFirst()));
        }
            
        if (lockedByHediff != null && pawn.health.hediffSet.HasHediff(lockedByHediff))
        {
            allRequirementLock.Add("BEWH.Framework.RankSystem.CategoryRequiredHediff".Translate(lockedByHediff.label.CapitalizeFirst()));
        }
            
        if (lockedByTrait != null && pawn.story.traits.HasTrait(lockedByTrait, lockTraitDegree))
        {
            allRequirementLock.Add("BEWH.Framework.RankSystem.CategoryRequiredTrait".Translate(lockedByTrait.DataAtDegree(lockTraitDegree).label.CapitalizeFirst()));
        }
        //locked by stuff here and then test
        
        if (allRequirementLock.Count > 0)
        {
            stringBuilder.AppendLineIfNotEmpty();
            stringBuilder.Append("BEWH.Framework.RankSystem.CategoryRequiresLock".Translate(label.CapitalizeFirst()));
            for (var i = 0; i < allRequirementLock.Count; i++)
            {
                stringBuilder.Append(allRequirementLock[i]);
                if (i + 2 == allRequirementLock.Count)
                {
                    stringBuilder.Append("BEWH.Framework.RankSystem.And".Translate());
                }
                else if (i + 2 < allRequirementLock.Count)
                {
                    stringBuilder.Append(", ");
                }
            }
        }   

        return stringBuilder.ToString();
    }
}